\title{coproduct}
\author{dannypsnl}

\<html:details>{\<html:summary>{#{\triangle} Helpers}
\agda{
module coproduct where
open import foundation

variable
  l : Level

ğŸ™ : UU
ğŸ™ = unit

âˆ… : UU
âˆ… = empty
}
}

\p{We can prove that a type plus empty type is equiv to itself, so \code{ğ”¸ + âˆ… â‰ƒ ğ”¸}.}

\agda{
module ğ”¸+âˆ… (ğ”¸ : UU l) where
  f : ğ”¸ + âˆ… â†’ ğ”¸
  f (inl a) = a
  f (inr ())

  add-nothing : ğ”¸ + âˆ… â‰ƒ ğ”¸
  pr1 add-nothing = f
  pr1 (pr2 add-nothing) = (Î» a â†’ inl a) , Î» _ â†’ refl
  pr2 (pr2 add-nothing) = (Î» a â†’ inl a) , lem
    where
      lem : (a+âˆ… : ğ”¸ + âˆ…) â†’ inl (f a+âˆ…) ï¼ a+âˆ…
      lem (inl a) = refl
      lem (inr ())
}

\p{We can also see that the \code{+} is symmetric, which means \code{ğ”¸ + ğ”¹ â‰ƒ ğ”¹ + ğ”¸}.}

\agda{
module Symm (ğ”¸ ğ”¹ : UU l) where
  g : ğ”¸ + ğ”¹ â†’ ğ”¹ + ğ”¸
  g (inl a) = inr a
  g (inr b) = inl b
  g' : ğ”¹ + ğ”¸ â†’ ğ”¸ + ğ”¹
  g' (inl b) = inr b
  g' (inr a) = inl a

  lemâ‚ : (x : ğ”¹ + ğ”¸) â†’ (g âˆ˜ g') x ï¼ x
  lemâ‚ (inl a) = refl
  lemâ‚ (inr b) = refl

  lemâ‚‚ : (x : ğ”¸ + ğ”¹) â†’ (g' âˆ˜ g) x ï¼ x
  lemâ‚‚ (inl a) = refl
  lemâ‚‚ (inr b) = refl

  +-symm : ğ”¸ + ğ”¹ â‰ƒ ğ”¹ + ğ”¸
  pr1 +-symm = g
  pr1 (pr2 +-symm) = g' , Î» x â†’ lemâ‚ x
  pr2 (pr2 +-symm) = g' , Î» x â†’ lemâ‚‚ x
}

\agda{
module _ (ğ”¸ : UU) where
  lemma : âˆ… + ğ”¸ â‰ƒ ğ”¸ + âˆ…
  lemma = Symm.+-symm âˆ… ğ”¸

  lemmaâ‚‚ : âˆ… + ğ”¸ â‰ƒ ğ”¸
  lemmaâ‚‚ = equivalence-reasoning
      âˆ… + ğ”¸
    â‰ƒ ğ”¸ + âˆ…
      by lemma
    â‰ƒ ğ”¸
      by ğ”¸+âˆ….add-nothing ğ”¸
}
